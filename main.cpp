#include<iostream>#include<vector>#include<cstring>#include "Matrix.h"class Martrix {public:    Martrix() = default;    Martrix(int m, int n);    ~Martrix() = default;    void setMartrix(int m, int n);    Martrix getIncidenceMartrix();    Martrix getAdjacentMArtrix();    void showMartrix();    int getNumOfTrees();    Martrix getATree();    bool isconnected();    Martrix getCompleGraph(Martrix Tree);    void showBasicCircuitSystem(Martrix Tree);    void showBasicBreakSystem(Martrix Tree);    void showLoopSpace(Martrix Tree);    std::vector<std::vector<int>> M;    std::vector<char> m;};int getByte(char c, int n){    return (c >> n) & 1;}std::vector<std::vector<int>> add(std::vector<std::vector<int>> m1, std::vector<std::vector<int>> m2){    int m = m1.size();    int n = m1[0].size();    int p = m2[0].size();    std::vector<std::vector<int>> arr;    std::vector<int> t;    for (int i = 0; i < m; i++) {        for (int j = 0; j < p; j++) {            t.push_back(m1[i][j] + m2[i][j]);        }        arr.push_back(t);        t.erase(t.begin(), t.end());    }    return arr;}std::vector<std::vector<int>> mutil(std::vector<std::vector<int>> m1, std::vector<std::vector<int>> m2) {    int m = m1.size();    int n = m1[0].size();    int p = m2[0].size();    std::vector<std::vector<int>> arr;    std::vector<int> t;    for (int i = 0; i < m; i++) {        for (int j = 0; j < p; j++) {            int sum = 0;            for (int k = 0; k < n; k++) {                sum += m1[i][k] * m2[k][j];            }            t.push_back(sum);        }        arr.push_back(t);        t.erase(t.begin(), t.end());    }    return arr;}int main() {    Martrix A;    int n;    printf("矩阵阶数：");    std::cin >> n;    A.setMartrix(n, n);    Martrix incidenceMartrix;    incidenceMartrix = A.getIncidenceMartrix();    std::cout << "关联矩阵：" << std::endl;    incidenceMartrix.showMartrix();    int numOfTrees = incidenceMartrix.getNumOfTrees();    std::cout << "生成树数目：" << numOfTrees << std::endl;    if(numOfTrees){        printf("生成树的关联矩阵\n");        Martrix tree = incidenceMartrix.getATree();        tree.showMartrix();        printf("生成树的相邻矩阵\n");        Martrix treeTurnIntoAdjacentMartrix = tree.getAdjacentMArtrix();        treeTurnIntoAdjacentMartrix.showMartrix();        printf("基本回路系统\n");        incidenceMartrix.showBasicCircuitSystem(tree);        printf("基本割集系统\n");        incidenceMartrix.showBasicBreakSystem(tree);        //printf("补图");        //Martrix completeTree = incidenceMartrix.getCompleteGraph(tree);        //completeTree.showMartrix();    }    return 0;}/*输入案例50 1 1 0 01 0 0 0 01 0 0 0 00 0 0 0 10 0 0 1 050 1 1 1 01 0 1 0 01 1 0 1 01 0 1 0 10 0 0 1 070 1 1 1 0 0 11 0 1 0 1 0 01 1 0 0 0 1 11 0 0 0 0 0 10 1 0 0 0 0 00 0 1 0 0 0 01 0 1 1 0 0 0 *///打印矩阵void Martrix::showMartrix() {    int rows = M.size();    int cols = M[0].size();    for (int i = 0; i < rows; i++) {        for (int j = 0; j < cols; j++) {            std::cout << M[i][j];            if (j != cols - 1)                std::cout << " ";        }        std::cout << std::endl;    }}Martrix::Martrix(int m, int n) {    for (int i = 0; i < m; i++) {        std::vector<int> row;        for (int j = 0; j < n; j++)            row.push_back(0);        M.push_back(row);    }}//设置m*n且元素默认为0的矩阵void Martrix::setMartrix(int m, int n) {    M.clear();    for(int i = 0; i < m; i++){        std::vector<int> row;        for(int j = 0; j < n; j++){            int element;            std::cin >> element;            row.push_back(element);        }        M.push_back(row);    }}//将相邻矩阵导出为关联矩阵Martrix Martrix::getIncidenceMartrix() {    int n = M.size();    Martrix incidenceMartrix;    for(int i = 0; i < n; i++){        std::vector<int> row;        incidenceMartrix.M.push_back(row);    }    for(int i = 0; i < n; i++){        for(int j = i + 1; j < n; j++){            if(M[i][j] != 0){                for(int k = 0; k < n; k++){                    if(k == i || k == j)                        incidenceMartrix.M[k].push_back(1);                    else                        incidenceMartrix.M[k].push_back(0);                }            }        }    }    return incidenceMartrix;}//得到生成树的数量int Martrix::getNumOfTrees(){    int rows = M.size();    int cols = M[0].size();    unsigned cease = (1 << cols) - 1;    int num = 0;    unsigned choice = 0;    for(; choice <= cease; choice++){        std::vector<std::vector<int>> martrix;        for(int i = 0; i < rows - 1; i++){            std::vector<int> r;            martrix.push_back(r);        }        int numof1 = 0;        for(int i = 0; i <= cols; i++){            if(getByte(choice, i))                numof1++;        }        if(numof1 != rows - 1)            continue;        for(int i = 0; i < cols; i++){            if(getByte(choice, i)){                for(int j = 0; j < rows - 1; j++){                    martrix[j].push_back(M[j][i]);                }            }        }        if(valueOfMatrix(rows - 1, martrix)%2) {            num++;        }    }    return num;}//导出一个生成树Martrix Martrix::getATree(){    int rows = M.size();    int cols = M[0].size();    unsigned cease = (1 << cols) - 1;    unsigned choice = 0;    for(; choice <= cease; choice++){        Martrix tree;        for(int i = 0; i < rows; i++){            std::vector<int> r;            tree.M.push_back(r);        }        int numof1 = 0;        for(int i = 0; i <= cols; i++){            if(getByte(choice, i))                numof1++;        }        if(numof1 != rows - 1)            continue;        for(int i = 0; i < cols; i++){            if(getByte(choice, i)){                for(int j = 0; j < rows; j++){                    tree.M[j].push_back(M[j][i]);                }            }        }        if(valueOfMatrix(rows - 1, tree.M)%2) {            return tree;        }    }}//将关联矩阵导出为相邻矩阵Martrix Martrix::getAdjacentMArtrix() {    int m = M.size();    int n = M[0].size();    Martrix adjacentMartrix(m, m);    for(int j = 0; j < n; j++) {        for (int x1 = 0; x1 < m - 1; x1++) {            for (int x2 = x1 + 1; x2 < m; x2++) {                if(M[x1][j] == 1 && M[x2][j] == 1){                    adjacentMartrix.M[x1][x2] = 1;                    adjacentMartrix.M[x2][x1] = 1;                }            }        }    }    return adjacentMartrix;}//打印基本回路系统void Martrix::showBasicCircuitSystem(Martrix Tree) {    int m = M.size();    int n = M[0].size();    Martrix complementTree = this->getCompleGraph(Tree);    //complementTree.showMartrix();    std::cout << "{";    int tm = complementTree.M[0].size();    for(int j1 = 0; j1 < tm; j1++){        unsigned choice = 0;        unsigned cease = (1 << Tree.M[0].size()) - 1;        for( ; choice <= cease; choice++){            Martrix basicCurcuit;            for(int i = 0; i < m; i++){                std::vector<int> row;                basicCurcuit.M.push_back(row);            }            for(int i = 0; i < m; i++){                basicCurcuit.M[i].push_back(complementTree.M[i][j1]);            }            std::vector<int> numbers;            for(int j = 0; j < Tree.M[0].size(); j++){                if(getByte(choice, j)){                    for(int i = 0; i < m; i++){                        basicCurcuit.M[i].push_back(Tree.M[i][j]);                    }                    numbers.push_back(j);                }            }            int flag = 1;            for(int i = 0; i < m; i++){                int d = 0;                for(int j = 0; j < basicCurcuit.M[0].size(); j++){                    d += basicCurcuit.M[i][j];                }                if(d != 2 && d != 0){                    flag = 0;                    break;                }            }            if(flag == 1){                //printf("\n");                //basicCurcuit.showMartrix();                //printf("\n");                if(j1 != 0)                    std::cout << ",";                std::cout << " e" << j1+1 << "'";                for(int i = 0; i < numbers.size(); i++){                    std::cout << "e" << numbers[i] + 1;                }                break;            }        }    }    std::cout << "}\n";}//传入此图的一个生成树作为参数，导出生成树的补图Martrix Martrix::getCompleGraph(Martrix Tree) {    Martrix complementTree;    int m = M.size();    int n = M[0].size();    for(int i = 0; i < m; i++){        std::vector<int> row;        complementTree.M.push_back(row);    }    for(int j1 = 0; j1 < n; j1++){        int flag = 0;        for(int j2 = 0; j2 < Tree.M[0].size(); j2++){            int flag2 = 1;            for(int i = 0; i < m; i++){                if(Tree.M[i][j2] != M[i][j1]){                    flag2 = 0;                    break;                }            }            if(flag2 == 1){                flag = 1;                break;            }        }        if(flag == 0){            for(int i = 0; i < m; i++){                complementTree.M[i].push_back(M[i][j1]);            }        }    }    return complementTree;}//打印基本割集系统void Martrix::showBasicBreakSystem(Martrix Tree) {    Martrix compleTree = this->getCompleGraph(Tree);    std::cout << "{";    for(int j1 = 0; j1 < Tree.M[0].size(); j1++){        unsigned choice = 0;        unsigned cease = (1 << compleTree.M[0].size()) - 1;        for(; choice <= cease; choice++){            Martrix basicBreak;            for(int i = 0; i < this->M.size(); i++){                std::vector<int> row;                basicBreak.M.push_back(row);            }            for(int i = 0; i < this->M.size(); i++){                basicBreak.M[i].push_back(Tree.M[i][j1]);            }            std::vector<int> numbers;            for(int j = 0; j < compleTree.M[0].size(); j++){                if(getByte(choice, j)){                    for(int i = 0; i < this->M.size(); i++){                        basicBreak.M[i].push_back(compleTree.M[i][j]);                    }                    numbers.push_back(j);                }            }            Martrix tempMartrix = this->getCompleGraph(basicBreak);            Martrix adjacentMartrix = tempMartrix.getAdjacentMArtrix();            if(!adjacentMartrix.isconnected()){                if(j1 != 0)                    std::cout << ",";                std::cout << "{ e" << j1 + 1;                for(int i = 0; i < numbers.size(); i++){                    std::cout << ",";                    std::cout << "e" << numbers[i] + 1<< "'";                }                std::cout << "}";                break;            }        }    }    std::cout << "}" << std::endl;}//判断是否为连通图bool Martrix::isconnected() {    int m = M.size();    int n = M[0].size();    Martrix A, B, C;    A.M = M;    B.M = M;    C.M = M;    for (int i = 2; i < m; i++) {        A.M = mutil(A.M, C.M);        B.M = add(A.M,B.M);    }    //B.showMartrix();    int flag = 1;    for (int i = 0; i < m; i++)        for (int j = 0; j < n; j++) {            if (B.M[i][j] == 0 && i != j)                flag = 0;        }    return flag;}void Martrix::showLoopSpace(Martrix Tree) {    Martrix compleTree = this->getCompleGraph(Tree);    std::cout << "{";    for(int j1 = 0; j1 < Tree.M[0].size(); j1++){        unsigned choice = 0;        unsigned cease = (1 << compleTree.M[0].size()) - 1;        for(; choice <= cease; choice++){            Martrix basicBreak;            for(int i = 0; i < this->M.size(); i++){                std::vector<int> row;                basicBreak.M.push_back(row);            }            for(int i = 0; i < this->M.size(); i++){                basicBreak.M[i].push_back(Tree.M[i][j1]);            }            std::vector<int> numbers;            for(int j = 0; j < compleTree.M[0].size(); j++){                if(getByte(choice, j)){                    for(int i = 0; i < this->M.size(); i++){                        basicBreak.M[i].push_back(compleTree.M[i][j]);                    }                    numbers.push_back(j);                }            }            Martrix tempMartrix = this->getCompleGraph(basicBreak);            Martrix adjacentMartrix = tempMartrix.getAdjacentMArtrix();            if(!adjacentMartrix.isconnected()){                if(j1 != 0)                    std::cout << ",";                std::cout << "{ e" << j1 + 1;                for(int i = 0; i < numbers.size(); i++){                    std::cout << ",";                    std::cout << "e" << numbers[i] + 1<< "'";                }                std::cout << "}";                break;            }        }    }    std::cout << "}" << std::endl;}